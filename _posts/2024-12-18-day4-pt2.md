---
layout: post
title: Day 4 (pt. 2)
---

Daily Report: I completed the problem Longest Valid Parentheses. Using code from the function is_balanced() (which I'd written for a different assignment) as a starting point, I changed the format so that is_balanced() used a list instead of a stack as the main data type for more flexibility and more familiar methods. is_balanced() had also originally accepted inputs with any characters, and counted brackets [] and curly brackets {} as well as parentheses () as part of the balance, while the longest valid parentheses problem only dealt with parentheses. This change in datatypes wasn't too difficult to implement, as the method .pop() applies to both stacks and lists, and .push could easily be replaced by .append. 

As for the fully new function I wrote for this problem: longest_paren(), my original attempt was overly complex to a level where I confused myself. This was frustrating, as I had trouble even tracing my code using print statements throughout. I was also stuck using only the test case input of "()", which is a very specific case, and testing only for that did not allow the function to work for other inputs. Once I realized this and started a completely new code cell, I was able to rethink the structure of my code. I ended up with nested for loops iterating through the indeces for the start and stops of sliced substrings. As I iterated through, long balanced substrings (checked using the modified is_balanced), could be stored away unless/until they were replaced by a longer substring. After taking a quick break and re structuring my thought process, the problem was a lot less difficult than I'd made it out to be, and it was exciting to get the code to work. 

Working on this problem helped remind me of the importance of outlines, as I more or less jumped right into writing the code for longest_paren() under the idea that calling is_balanced() would have taken care of the brunt of the work. Though the solution I came up with in the end was not overly complex, it was a useful reminder to think things through before implementing. Looking back I also could have taken into account that as a beginning coder, it could be difficult for to accurately predict the scale or intensity necessary for a function.

I had chosen Longest Valid Parentheses as a problem because it sounded both doable and interesting because it didn't just count substrings from the beginning and therefore had to account for different starting indeces in addition to stopping indeces. I'm happy with how it turned out, as I was able to both manipulate existing code to my benefit and write a new original function more specific to the problem.

[Here](../files/LeetCode_Final_Quest.ipynb) is the link to the python notebook with my LeetCode problems (and their prompts)
